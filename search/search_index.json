{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started \ud83d\udd17 First of all the code has to be generated. This is done using a OpenAPI v3 specification file which is located at docs/openapi.yaml . Generate the codebase \ud83d\udd17 poetry install ; poertry run generate_fastapi ; Manual configuration \ud83d\udd17 The idea is that all logic that it adapter specific (e.g. specific workflows) are defined in one or more controller classes that are implemented manually. The generated code, however, defines a basic interface which the controller class needs to implement: class Controller : async def get_download_media ( self , media_id : Any ) -> Union [ bytes , APIResponse ]: raise NotImplementedException () async def post_send_message ( self , body : Any ) -> Union [ None , APIResponse ]: raise NotImplementedException () async def post_upload_media ( self , file : Any ) -> APIResponse : raise NotImplementedException () An approriate controller class can then be used by replacing the corresponding placeholder in main.py : controller = Controller () # Replace this with the actual controller implementation configure_routes__downloadMedia_media_id ( app , controller ) configure_routes__sendMessage ( app , controller ) configure_routes__uploadMedia ( app , controller ) Further plans \ud83d\udd17 Test further cases like other file uploads, exception handling Add an upstream client SDK which is also generated using an OpenAPI v3 specification (see openapi-python-client )","title":"Overview"},{"location":"#getting-started","text":"First of all the code has to be generated. This is done using a OpenAPI v3 specification file which is located at docs/openapi.yaml .","title":"Getting started"},{"location":"#generate-the-codebase","text":"poetry install ; poertry run generate_fastapi ;","title":"Generate the codebase"},{"location":"#manual-configuration","text":"The idea is that all logic that it adapter specific (e.g. specific workflows) are defined in one or more controller classes that are implemented manually. The generated code, however, defines a basic interface which the controller class needs to implement: class Controller : async def get_download_media ( self , media_id : Any ) -> Union [ bytes , APIResponse ]: raise NotImplementedException () async def post_send_message ( self , body : Any ) -> Union [ None , APIResponse ]: raise NotImplementedException () async def post_upload_media ( self , file : Any ) -> APIResponse : raise NotImplementedException () An approriate controller class can then be used by replacing the corresponding placeholder in main.py : controller = Controller () # Replace this with the actual controller implementation configure_routes__downloadMedia_media_id ( app , controller ) configure_routes__sendMessage ( app , controller ) configure_routes__uploadMedia ( app , controller )","title":"Manual configuration"},{"location":"#further-plans","text":"Test further cases like other file uploads, exception handling Add an upstream client SDK which is also generated using an OpenAPI v3 specification (see openapi-python-client )","title":"Further plans"}]}